# 🧩 Problem 26: Rotate Left in an 8-bit Register

### 📝 Problem Statement

Write a **C program** to perform a **left circular rotation** on an **8-bit register** by `n` positions.

In a **left circular rotation**, bits shifted out from the left end are wrapped around and placed at the right end.

The program should:

* Take two inputs:

  * `reg` → an 8-bit unsigned integer (i.e., a value from `0` to `255`)
  * `n` → the number of positions to rotate (0–7)
* Perform a **circular left rotation** by `n` positions
* Return the result as an 8-bit value
* Print the result

---

### ✅ Examples

#### Example 1

```
Input:
reg = 0b10110000
n = 1

Output:
0b01100001
```

**Explanation**:

```
Rotate left by 1:
    10110000 → 01100001
```

---

#### Example 2

```
Input:
reg = 0b10000001
n = 2

Output:
0b00000110
```

**Explanation**:

```
Rotate left by 2:
    10000001 → 00000110
```

---

#### Example 3

```
Input:
reg = 0b11111111
n = 4

Output:
0b11111111
```

**Explanation**:

```
All bits are 1, so rotating does not change the value.
```

---

### 💡 Hint

* Rotating left `n` positions in an 8-bit value:

  ```c
  (reg << n) | (reg >> (8 - n))
  ```

* Use `n % 8` to avoid undefined behavior if `n >= 8`

* Cast the result to `uint8_t` to ensure it remains within 8 bits:

  ```c
  return (uint8_t)((reg << n) | (reg >> (8 - n)));
  ```

---

### 💻 Solution (C)

```c
#include <stdio.h>
#include <stdint.h>

uint8_t rotate_left(uint8_t reg, uint8_t n) {
    n %= 8;
    return (reg << n) | (reg >> (8 - n));
}

int main() {
    uint8_t reg, n;
    scanf("%hhu %hhu", &reg, &n);
    printf("%u", rotate_left(reg, n));
    return 0;
}
```