# ğŸ§© Problem 27: Rotate Right in a 32-bit Register

### ğŸ“ Problem Statement

Write a **C program** to perform a **right circular rotation** on a **32-bit register** by `n` positions.

In a **right circular rotation**, bits shifted out from the right end reappear on the left end.

The program should:

* Take two inputs:

  * `reg` â†’ a 32-bit unsigned integer (the register value)
  * `n` â†’ number of positions to rotate (0â€“31)
* Perform a **circular right rotation** of the bits in `reg` by `n` positions
* Print the **updated register** value

---

### âœ… Examples

#### Example 1

```
Input:
reg = 0b00000000 00000000 00000000 00001111
n = 4

Output:
0b11110000 00000000 00000000 00000000
```

**Explanation**:

```
Right rotate by 4 moves the 4 LSBs to the 4 MSBs.
```

---

#### Example 2

```
Input:
reg = 0b00000000 00000000 00000000 00000001
n = 1

Output:
0b10000000 00000000 00000000 00000000
```

---

#### Example 3

```
Input:
reg = 0b10000000 00000000 00000000 00000000
n = 2

Output:
0b00100000 00000000 00000000 00000000
```

---

### ğŸ’¡ Hint

* A right circular rotation of `n` bits on a 32-bit value:

  ```c
  (reg >> n) | (reg << (32 - n))
  ```

* Always perform `n % 32` to handle overflow or invalid shift amounts

* Cast to `uint32_t` if needed to ensure result stays in 32 bits

---

### ğŸ’» Solution (C)

```c
#include <stdio.h>
#include <stdint.h>

uint32_t rotate_right(uint32_t reg, uint8_t n) {
    n %= 32;
    return (reg >> n) | (reg << (32 - n));
}

int main() {
    uint32_t reg;
    uint8_t n;
    scanf("%u %hhu", &reg, &n);
    printf("%u", rotate_right(reg, n));
    return 0;
}
```