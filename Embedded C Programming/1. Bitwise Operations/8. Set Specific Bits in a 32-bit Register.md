# 🧩 Problem 8: Set Specific Bits in a 32-bit Register

### 📝 Problem Statement

Write a **C program** to **set a sequence of bits to 1** in a **32-bit register**, starting from a given bit position and covering a given length — without modifying any other bits in the register.

The program should:

* Take three inputs:

  * `reg` → a 32-bit unsigned integer representing the register value
  * `pos` → the starting bit position (0-based index, 0 = LSB)
  * `len` → the number of bits to set to 1
* Set those `len` bits starting at `pos` to `1`
* Print the **updated register** in binary format

---

### ✅ Examples

#### Example 1

```
Input:
reg = 0b0000 0000 0000 0000 0000 0000 0000 0000
pos = 4
len = 3

Output: 0b0000 0000 0000 0000 0000 0000 0111 0000
```

**Explanation**: 

```
Setting bits 4, 5, and 6 to `1` → `0b01110000
```

---

#### Example 2

```
Input:
reg = 0b0000 0000 0000 0000 0000 0000 0000 0001
pos = 1
len = 2

Output: 0b0000 0000 0000 0000 0000 0000 0000 0111
```

**Explanation**: 

```
Setting bits 1 and 2 to `1` → changes register to `0b00000111`
```
---

### 💡 Hint

To set multiple bits to 1 without changing other bits:

1. Create a **bitmask** with `len` bits set to 1:

   ```c
   (1U << len) - 1
   ```
2. Shift that mask to the target position:

   ```c
   ((1U << len) - 1) << pos
   ```
3. Use **bitwise OR** to set the bits:

   ```c
   reg | (((1U << len) - 1) << pos)
   ```

---

### 💻 Solution (C)

```c
#include <stdio.h>
#include <stdint.h>

uint32_t set_bits(uint32_t reg, uint8_t pos, uint8_t len) {
    return reg | (((1U << len)-1)<< pos);
}

int main() {
    uint32_t reg;
    uint8_t pos, len;
    scanf("%u %hhu %hhu", &reg, &pos, &len);
    printf("%u", set_bits(reg, pos, len));
    return 0;
}
```