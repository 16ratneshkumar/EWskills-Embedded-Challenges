# 🧩 Problem 38: Serialized Data Buffer

### 📝 Problem Statement

In embedded systems and firmware development, communication packets are often built as **byte arrays** for transmission over protocols like UART or SPI.

You are given the following fields to build a serialized data packet:

| **Field** | **Size** | **Description**              |
| --------- | -------- | ---------------------------- |
| Start     | 1 byte   | Always `0xA5`                |
| Command   | 1 byte   | User input (`uint8_t`)       |
| Value     | 2 bytes  | 16-bit data (`uint16_t`)     |
| Status    | 1 byte   | Flag (`0` or `1`, `uint8_t`) |
| Checksum  | 4 bytes  | 32-bit checksum (`uint32_t`) |
| End       | 1 byte   | Always `0x5A`                |

---

### 👉 Your Task

Write a **C program** to:

1. Create a `uint8_t buffer[10]` and fill it with the data fields in the correct order.
2. Convert multi-byte fields (`Value`, `Checksum`) into **little-endian** byte format.
3. Print the entire buffer as **space-separated integers**.

---

### ✅ Examples

#### Example 1

```
Input:
Command = 0x01
Value = 0x1234
Status = 1
Checksum = 0xAABBCCDD

Output:
165 1 52 18 1 221 204 187 170 90
```

*Explanation:*

* Start = `0xA5` = 165
* Command = `0x01` = 1
* Value = `0x1234` = \[52, 18] (little-endian)
* Status = 1
* Checksum = `0xAABBCCDD` = \[221, 204, 187, 170] (little-endian)
* End = `0x5A` = 90

---

#### Example 2

```
Input:
Command = 0xFF
Value = 0x00FF
Status = 0
Checksum = 0x01020304

Output:
165 255 255 0 0 4 3 2 1 90
```

---

### 💡 Hint

Use bit shifting and masking to extract individual bytes from `uint16_t` and `uint32_t` values. Remember that little-endian means **least significant byte comes first**.

---

### 💻 Solution: Build Packet in Little-Endian Format

```c
#include <stdio.h>
#include <stdint.h>

void build_packet(uint8_t command, uint16_t value, uint8_t status, uint32_t checksum) {
    uint8_t buffer[10];

    buffer[0] = 0xA5;                      // Start byte
    buffer[1] = command;                  // Command
    buffer[2] = value & 0xFF;             // Value LSB
    buffer[3] = (value >> 8) & 0xFF;      // Value MSB
    buffer[4] = status;                   // Status
    buffer[5] = checksum & 0xFF;          // Checksum byte 0 (LSB)
    buffer[6] = (checksum >> 8) & 0xFF;   // Checksum byte 1
    buffer[7] = (checksum >> 16) & 0xFF;  // Checksum byte 2
    buffer[8] = (checksum >> 24) & 0xFF;  // Checksum byte 3 (MSB)
    buffer[9] = 0x5A;                     // End byte

    // Print buffer
    for (int i = 0; i < 10; i++) {
        printf("%u", buffer[i]);
        if (i < 9) {
            printf(" ");
        }
    }
}

int main() {
    uint8_t cmd, status;
    uint16_t val;
    uint32_t crc;

    scanf("%hhu %hu %hhu %u", &cmd, &val, &status, &crc);
    build_packet(cmd, val, status, crc);
    return 0;
}
```