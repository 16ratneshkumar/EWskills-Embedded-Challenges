# ğŸ§© Problem 36: Find Duplicate in Range 0 and n-1

### ğŸ“ Problem Statement

You are given an array of `n` integers where:

* Each number is in the range `[0, n-1]`
* **Exactly one number** is **repeated once**
* You **cannot modify** the array
* You must use **O(1) extra space**

Write a **C program** to **find and print the repeated number**.

---

### âœ… Examples

#### Example 1

```
Input:
n = 5
arr = [0 1 2 3 2]

Output:
2
```

#### Example 2

```
Input:
n = 6
arr = [5 4 3 2 1 3]

Output:
3
```

#### Example 3

```
Input:
n = 4
arr = [1 0 2 0]

Output:
0
```

---

### ğŸ’¡ Hint

You cannot:

* Modify the array
* Use extra memory (like hash maps or boolean arrays)

Try comparing elements using nested loops. While this takes **O(nÂ²)** time, it meets the **O(1)** space and **no modification** constraint.

---

### ğŸ’» Solution: Brute Force Comparison (O(nÂ²), O(1) space)

```c
#include <stdio.h>

int find_duplicate(int arr[], int n) {
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (arr[i] == arr[j]) {
                return arr[i];
            }
        }
    }
}

int main() {
    int n;
    int arr[100];

    scanf("%d", &n);

    for (int i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }

    int result = find_duplicate(arr, n);
    printf("%d", result);

    return 0;
}
```

## ğŸ’» Solution 2: Diagonal Comparison Variant (Also O(nÂ²), O(1) Space)

This is a different brute-force style: shift comparison starting at `j = 1` offset to reduce some repeated comparisons.

```c
#include <stdio.h>

int find_duplicate(int arr[], int n) {
    int j = 0;

    while (1) {
        for (int i = 0; i + j + 1 < n; i++) {
            if (arr[i] == arr[i + j + 1]) {
                return arr[i];
            }
        }
        j++;
    }
}

int main() {
    int n;
    int arr[100];

    scanf("%d", &n);

    for (int i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }

    int result = find_duplicate(arr, n);
    printf("%d", result);

    return 0;
}
```