# 🧩 Problem 101: Identify Trap in Signed vs Unsigned Comparison

### 📝 Problem Statement

In C, comparing signed and unsigned integers can lead to **unexpected behavior** due to **integer promotion rules**.

You're given:

* A signed 8-bit integer: `int8_t a`
* An unsigned 8-bit integer: `uint8_t b`

You need to:

1. Perform the comparison `a < b`
2. Return:

   * `1` if the condition is **true**
   * `0` if the condition is **false**
3. Avoid the **signed-to-unsigned promotion trap**, which can occur when a negative `int8_t` value is promoted to a large `uint8_t` value in a mixed-type comparison.

---

### ❗️ Signed vs Unsigned Trap

In C, when comparing a signed and unsigned type:

* The signed value is **converted to unsigned**, which may cause **negative values to appear very large**.
* For example, `-1` (signed) becomes `255` (unsigned) during comparison.

---

### ✅ Examples

#### Example 1

```
Input:
a = -1, b = 1

Output:
1
```

*Explanation:* -1 is less than 1. But without safe handling, `a` may get promoted to `255`, making the result incorrect.

---

#### Example 2

```
Input:
a = 250, b = 240

Output:
1
```

*Explanation:* `int8_t a = 250` wraps to `-6`, so it's less than 240.

---

#### Example 3

```
Input:
a = -128, b = 255

Output:
1
```

---

### 💡 Hint

Use a check like:

```c
if (a < 0)
    return 1;
else
    return ((uint8_t)a < b);
```

This preserves the **actual intent** of comparing `a` and `b` as real numbers.

---

### 💻 Solution: Safe Signed vs Unsigned Comparison

```c
#include <stdio.h>
#include <stdint.h>

int safe_compare(int8_t a, uint8_t b) {
    // If 'a' is negative, it's always less than any uint8_t
    if (a < 0) {
        return 1;
    }
    // Both are now non-negative, compare safely
    return ((uint8_t)a < b);
}

int main() {
    int8_t a;
    uint8_t b;
    scanf("%hhd %hhu", &a, &b);
    printf("%d", safe_compare(a, b));
    return 0;
}
```