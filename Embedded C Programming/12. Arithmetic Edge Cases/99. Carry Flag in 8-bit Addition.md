# 🧩 Problem 99: Carry Flag in 8-bit Addition

### 📝 Problem Statement

You are given two 8-bit unsigned integers: `a` and `b`. Your task is to:

* Add them using **only 8-bit arithmetic**
* Print the result as it would appear in an 8-bit register (i.e., wraps on overflow)
* Print the **carry flag**:
  `1` if overflow occurred (i.e., sum > 255), otherwise `0`

You must **not use `uint16_t` or any larger types** — stay within 8-bit operations only.

---

### ✅ Examples

#### Example 1

```
Input:
255 1

Output:
0 1
```

#### Example 2

```
Input:
200 100

Output:
44 1
```

#### Example 3

```
Input:
50 20

Output:
70 0
```

---

### 💡 Hint

* You can detect overflow by checking if the result is less than either operand.
* Alternatively, use bit-shifting: `(a + b) >> 8` yields `1` if overflow occurred.

---

### 💻 Solution (C)

#### ✅ Version 1: Using Comparison

```c
#include <stdio.h>
#include <stdint.h>

void add_with_carry(uint8_t a, uint8_t b, uint8_t* result, uint8_t* carry) {
    *result = a + b;
    *carry = (*result < a) ? 1 : 0;
}

int main() {
    uint8_t a, b, result, carry;
    scanf("%hhu %hhu", &a, &b);
    
    add_with_carry(a, b, &result, &carry);

    printf("%u %u", result, carry);
    return 0;
}
```

---

#### ✅ Version 2: Using Bit Shift

```c
#include <stdio.h>
#include <stdint.h>

void add_with_carry(uint8_t a, uint8_t b, uint8_t* result, uint8_t* carry) {
    *result = a + b;
    *carry = (a + b) >> 8;
}

int main() {
    uint8_t a, b, result, carry;
    scanf("%hhu %hhu", &a, &b);
    
    add_with_carry(a, b, &result, &carry);

    printf("%u %u", result, carry);
    return 0;
}
```