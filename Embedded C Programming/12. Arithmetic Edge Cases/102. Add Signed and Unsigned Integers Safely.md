# 🧩 Problem 102: Add Signed and Unsigned Integers Safely

### 📝 Problem Statement

In C, mixing signed and unsigned types in arithmetic operations can result in **unexpected behavior** due to implicit type promotions.

You are given:

* A signed 8-bit integer: `int8_t a`
* An unsigned 8-bit integer: `uint8_t b`

Your task is to:

1. **Add** `a + b` in a way that **preserves the sign** of `a` (if negative)
2. Return the result as a **signed 16-bit integer (`int16_t`)** so you can observe overflow behavior if it occurs

---

### ✅ Examples

#### Example 1

```
Input:
a = -10, b = 20

Output:
10
```

*Explanation:* `-10 + 20 = 10`

---

#### Example 2

```
Input:
a = 10, b = 250

Output:
260
```

*Explanation:* No overflow because result fits in 16 bits.

---

#### Example 3

```
Input:
a = -128, b = 255

Output:
127
```

*Explanation:* `-128 + 255 = 127` — correctly handled.

---

### ❗️ C Pitfall

In C, if you write `a + b` directly where `a` is `int8_t` and `b` is `uint8_t`, the compiler promotes `a` to `unsigned int`, potentially breaking the expected signed behavior.

---

### 💡 Hint

Cast both `a` and `b` to `int16_t` before addition to **preserve signedness** and avoid promotion issues.

---

### 💻 Solution: Safe Signed + Unsigned Addition

```c
#include <stdio.h>
#include <stdint.h>

int16_t signed_unsigned_sum(int8_t a, uint8_t b) {
    return (int16_t)a + (int16_t)b;
}

int main() {
    int8_t a;
    uint8_t b;
    scanf("%hhd %hhu", &a, &b);
    printf("%d", signed_unsigned_sum(a, b));
    return 0;
}
```