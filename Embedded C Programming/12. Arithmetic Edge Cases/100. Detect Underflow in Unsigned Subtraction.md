# 🧩 Problem 100: Detect Underflow in Unsigned Subtraction

### 📝 Problem Statement

In embedded systems, subtracting unsigned values is common — but it may result in **underflow** if the subtrahend is greater than the minuend. This causes the result to **wrap around** due to the unsigned nature of the data type.

Given two **8-bit unsigned integers** `a` and `b`, your task is to:

* Compute `diff = a - b` (using wraparound if needed)
* Detect **underflow**, and set a flag `carry`:

  * `carry = 1` if **underflow occurred** (i.e., `b > a`)
  * `carry = 0` otherwise

---

### ✅ Examples

#### Example 1

```
Input:
a = 100, b = 50

Output:
diff = 50, carry = 0
```

*Explanation:* No underflow, since 100 ≥ 50.

---

#### Example 2

```
Input:
a = 10, b = 20

Output:
diff = 246, carry = 1
```

*Explanation:* Underflow occurred.
Unsigned 8-bit: `10 - 20` wraps to `246` (`256 + 10 - 20`)

---

#### Example 3

```
Input:
a = 0, b = 0

Output:
diff = 0, carry = 0
```

---

### 💡 Hint

In unsigned subtraction:

* `a - b` wraps around automatically in C if `a < b`
* To detect underflow, simply check: `if (a < b)`

---

### 💻 Solution: Detecting Underflow with Unsigned Integers

```c
#include <stdio.h>
#include <stdint.h>

void subtract_with_underflow(uint8_t a, uint8_t b, uint8_t *diff, uint8_t *carry) {
    *diff = a - b;                // Wraparound subtraction
    *carry = (a < b) ? 1 : 0;     // Underflow detection
}

int main() {
    uint8_t a, b, diff, carry;
    scanf("%hhu %hhu", &a, &b);   // Read two unsigned 8-bit integers
    subtract_with_underflow(a, b, &diff, &carry);
    printf("diff = %u, carry = %u", diff, carry);
    return 0;
}
```