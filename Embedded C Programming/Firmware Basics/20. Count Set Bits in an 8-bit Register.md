# 🧩 Problem 20: Count Set Bits in an 8-bit Register

### 📝 Problem Statement

Write a **C program** to **count the number of bits set to 1** in an **8-bit register**.

The program should:

* Take a single input:

  * `reg` → an 8-bit unsigned integer (i.e. a value from `0` to `255`)
* Count how many bits are set (i.e. bits that are `1`)
* Print the count as an integer

---

### ✅ Examples

#### Example 1

```
Input:
reg = 0b00001111

Output:
4
```

#### Example 2

```
Input:
reg = 0b11110000

Output:
4
```

#### Example 3

```
Input:
reg = 0b00000000

Output:
0
```

#### Example 4

```
Input:
reg = 0b11111111

Output:
8
```

---

### 💡 Hint

There are multiple ways to count set bits in a register:

#### ✅ Method 1: Bitwise AND + Shift

Check each bit using `(reg & 1)` and then right-shift the register.

#### ✅ Method 2: Brian Kernighan’s Algorithm (Efficient)

This method repeatedly clears the **lowest set bit**, reducing the number of operations to the number of 1s.

```c
reg &= (reg - 1);
```

---

### 💻 Solution 1: Basic Bitwise AND and Shift

```c
#include <stdio.h>
#include <stdint.h>

uint8_t count_set_bits(uint8_t reg) {
    uint8_t count = 0;
    while (reg) {
        count += (reg & 1); 
        reg >>= 1;
    }
    return count;
}

int main() {
    uint8_t reg;
    scanf("%hhu", &reg);
    printf("%u", count_set_bits(reg));
    return 0;
}
```

---

### 💻 Solution 2: Optimized Using Brian Kernighan’s Algorithm

```c
#include <stdio.h>
#include <stdint.h>

uint8_t count_set_bits(uint8_t reg) {
    uint8_t count = 0;
    while (reg) {
        reg &= (reg - 1); 
        count++;
    }
    return count;
}

int main() {
    uint8_t reg;
    scanf("%hhu", &reg);
    printf("%u", count_set_bits(reg));
    return 0;
}
```