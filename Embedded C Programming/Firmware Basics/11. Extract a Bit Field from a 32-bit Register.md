# 🧩 Problem 11: Extract a Bit Field from a 32-bit Register

### 📝 Problem Statement

Write a **C program** to **extract a sequence of bits** from a **32-bit register**, starting from a given position and covering a given number of bits.

The program should:

* Take three inputs:

  * `reg` → a 32-bit unsigned integer representing the register value
  * `pos` → starting bit position (0-based index, 0 = LSB)
  * `len` → number of bits to extract
* Return the extracted bit field as an **unsigned integer**, right-aligned.

---

### ✅ Examples

#### Example 1

```
Input:
reg = reg = 0b1011 0110 0111 0000 0000 0000 0000 0000
pos = 28
len = 4

Output: 0b1011
```

**Explanation**: Bits from position 28 to 31 (MSB) are extracted → `1011` → Decimal: `11`

---

#### Example 2

```
Input:
reg = 0b0000 0000 0000 0000 0000 0000 1111 1111
pos = 0
len = 8

Output: 0b11111111
```

**Explanation**: Bits from position 0 to 7 are extracted → `11111111` → Decimal: `255`

---

### 💡 Hint

To extract a bit field:

1. Right-shift the register so that the field starts at bit 0:

   ```c
   reg >> pos
   ```
2. Mask the least significant `len` bits:

   ```c
   (1U << len) - 1
   ```
3. Combine:

   ```c
   (reg >> pos) & ((1U << len) - 1)
   ```

---

### 💻 Solution (C)

```c
#include <stdio.h>
#include <stdint.h>

uint32_t extract_field(uint32_t reg, uint8_t pos, uint8_t len) {
    return (reg >> pos) & ((1U << len)-1);
}

int main() {
    uint32_t reg;
    uint8_t pos, len;
    scanf("%u %hhu %hhu", &reg, &pos, &len);
    printf("%u", extract_field(reg, pos, len));
    return 0;
}
```

### ✅ Reason for `1U` instead of just `1`

* By default, the number `1` is treated as an `int` in C (usually a 32-bit **signed** integer).
* If you do `1 << len` with `len >= 31`, this can cause **undefined behavior** due to shifting a signed value into or past the sign bit.
* Using `1U` makes it an **unsigned int**, so:

  * It avoids undefined behavior for large shifts
  * It ensures correct bitwise operations without negative numbers involved

---

### 🛠 TL;DR

| Expression    | Meaning                        |
| ------------- | ------------------------------ |
| `1`           | Signed int (may overflow)      |
| `1U`          | Unsigned int (safe for shifts) |
| `1UL`, `1ULL` | Unsigned long / long long      |

So using `1U` ensures:

* **Safe shifting**
* **Correct unsigned math**
* **No overflow or signed bugs**

✅ **Always use `1U` when doing bit shifts for masks or positions.**
