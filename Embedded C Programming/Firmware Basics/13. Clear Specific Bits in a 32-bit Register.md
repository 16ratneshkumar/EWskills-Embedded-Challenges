# 🧩 Problem 13: Clear Specific Bits in a 32-bit Register

### 📝 Problem Statement

Write a **C program** to **clear a sequence of bits (set to 0)** in a **32-bit register**, starting from a given bit position and covering a given length — without modifying any other bits in the register.

The program should:

* Take three inputs:

  * `reg` → a 32-bit unsigned integer representing the register value
  * `pos` → the starting bit position (0-based index, 0 = LSB)
  * `len` → the number of bits to clear (set to 0)
* Clear those `len` bits starting at `pos`
* Print the **updated register** value.

---

### ✅ Examples

#### Example 1

```
Input:
reg = 0b1111 1111
pos = 4
len = 4

Output: 0b0000 1111
```

**Explanation**:
```
Bits 4 to 7 are cleared (set to 0), all other bits remain unchanged.
```

---

#### Example 2

```
Input:
reg = 0b0000 1111
pos = 0
len = 2

Output: 0b0000 1100
```

**Explanation**:
```
Bits 0 and 1 are cleared.
```

---

### 💡 Hint

To clear multiple bits to 0 without affecting others:

1. Create a **bitmask** with `len` bits set to 1:

   ```c
   (1U << len) - 1
   ```
2. Shift that mask to the target position:

   ```c
   ((1U << len) - 1) << pos
   ```
3. **Invert the mask** to get 0s where you want to clear:

   ```c
   ~(((1U << len) - 1) << pos)
   ```
4. Use **bitwise AND** to clear the bits:

   ```c
   reg & ~(((1U << len) - 1) << pos)
   ```

---

### 💻 Solution (C)

```c
#include <stdio.h>
#include <stdint.h>

uint32_t clear_bits(uint32_t reg, uint8_t pos, uint8_t len) {
    return reg & ~(((1U << len)-1)<<pos);
}

int main() {
    uint32_t reg;
    uint8_t pos, len;
    scanf("%u %hhu %hhu", &reg, &pos, &len);
    printf("%u", clear_bits(reg, pos, len));
    return 0;
}
```